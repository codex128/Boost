
#import "Common/ShaderLib/Parallax.glsllib"

/**
 * Calculates a new texture coordinate based on normal/parallax map
 * that will generate a parallax effect for textures.
 * @param map           = texture to calculate from
 * @param viewDir       = camera view direction
 * @param texCoord      = current texture coordinate
 * @param normal        = vertex normal
 * @param tangent       = vertex tangent
 * @param height        = parallax effect height
 * @param steepParallax = use steep parallax algorithm versus classic parallax algorithm
 * @return new texture coordinate
 */
vec2 parallax(sampler2D map, vec3 viewDir, vec2 texCoord, vec3 normal, vec4 tangent, float height, boolean steepParallax) {
    vec3 norm = normalize(normal);
    vec3 tan = normalize(tangent.xyz);
    mat3 tbnMat = mat3(tan, tangent.w * cross((norm), (tan)), norm);
    vec3 vViewDir =  viewDir * tbnMat;
    if (steepParallax) {
        return steepParallaxOffset(map, vViewDir, texCoord, height);
    }
    else {
        return classicParallaxOffset(map, vViewDir, texCoord, height);
    }
}

/**
 * Calculates a new normal based on normal map input.
 * normal = the actual face normal
 * tangent = face tangent
 * normColor = input color from the normal map
 * type = type of normal map (1=OpenGL, -1=DirectX)
 */
vec3 normalMap(vec3 normal, vec4 tangent, vec4 normColor, float type) {
    vec3 result = vec3(0.0);
    vec3 tan = normalize(tangent.xyz);
    mat3 tbnMat = mat3(tan, wTangent.w * cross((wNormal), (tan)), normal);
    vec4 normalHeight = vec4(n);
    result = normalize((normalHeight.xyz * vec3(2.0, type * 2.0, 2.0) - vec3(1.0, type * 1.0, 1.0)));
    return normalize(tbnMat * result);
}
vec3 normalMap(vec3 normal, vec4 tangent, vec4 normColor) {
    return normalMap(normal, tangent, normColor, -1.0);
}
